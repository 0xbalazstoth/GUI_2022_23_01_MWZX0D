using System;
using System.Collections.Generic;

namespace Pathfinding {
  class Program {
    static void Main(string[] args) {
      // create a grid
      int[,] grid = new int[,] {
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
      };

      // create a start and end point
      Point start = new Point(0, 0);
      Point end = new Point(9, 9);

      // create a list of points
      List<Point> path = new List<Point>();

      // add the start point to the list
      path.Add(start);

      // loop until the end point is found
      while (path[path.Count - 1] != end) {
        // get the last point in the list
        Point last = path[path.Count - 1];

        // get the adjacent points
        Point[] adjacent = new Point[] {
          new Point(last.x + 1, last.y),
          new Point(last.x - 1, last.y),
          new Point(last.x, last.y + 1),
          new Point(last.x, last.y - 1)
        };

        // loop through the adjacent points
        foreach (Point point in adjacent) {
          // check if the point is in the grid
          if (point.x >= 0 && point.x < grid.GetLength(0) && point.y >= 0 && point.y < grid.GetLength(1)) {
            // check if the point is not in the list
            if (!path.Contains(point)) {
              // add the point to the list
              path.Add(point);
            }
          }
        }
      }

      // print the path
      foreach (Point point in path) {
        Console.WriteLine(point);
      }
    }
  }

  class Point {
    public int x;
    public int y;

    public Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    public override string ToString() {
      return "(" + x + ", " + y + ")";
    }
  }
}